
---
format:
  html: {toc: true, toc-depth: 3, theme: cosmo, number-sections: false, output-file: assignments.hw3.utils.html}
code-block-background: true
include-in-header: {text: '<link rel = "icon" href = "data:," />'}
toc-title-numbers: false
number-depth: 0

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style><style>.clay-limit-image-width .clay-image {max-width: 100%}
.clay-side-by-side .sourceCode {margin: 0}
.clay-side-by-side {margin: 1em 0}
</style>
<script src="assignments.hw3.utils_files/md-default0.js" type="text/javascript"></script><script src="assignments.hw3.utils_files/md-default1.js" type="text/javascript"></script>

::: {.sourceClojure}
```clojure
(ns assignments.hw3.utils
  (:require
   [clojure.math.combinatorics :as combo]
   [scicloj.kindly.v4.api :as kindly]
   [scicloj.kindly.v4.kind :as kind]
   (uncomplicate.neanderthal
    [core :refer [mv]]
    [linalg :refer [trf! tri!]]
    [native :refer [dge dv]])))
```
:::



::: {.sourceClojure}
```clojure
(kind/md "## Utils")
```
:::


## Utils

Functions from HW3

Q2: Subset counting


::: {.sourceClojure}
```clojure
(defn count-subsets [n]
  (Math/pow 2 n))
```
:::


Q3: Occupancy problem


::: {.sourceClojure}
```clojure
(defn probability-one-cell-empty [n]
  (/ (* n (Math/pow (dec n) (dec n)))
     (Math/pow n n)))
```
:::


Q4: Coin flipping game


::: {.sourceClojure}
```clojure
(defn simulate-game []
  (loop [player :A]
    (if (= (rand-int 2) 0)                          ; 0 represents heads
      player
      (recur (if (= player :A) :B :A)))))
```
:::



::: {.sourceClojure}
```clojure
(defn simulate-many-games [n]
  (let [results (repeatedly n simulate-game)
        a-wins (count (filter #(= % :A) results))]
    (double (/ a-wins n))))
```
:::


Q7: AI Error Distribution


::: {.sourceClojure}
```clojure
(defn factorial [n]
  (apply * (range 1 (inc n))))
```
:::



::: {.sourceClojure}
```clojure
(defn stirling2 [n k]
  (cond
    (or (= k 0) (> k n)) 0
    (or (= k 1) (= k n)) 1
    :else (+ (* k (stirling2 (dec n) k))
             (stirling2 (dec n) (dec k)))))
```
:::



::: {.sourceClojure}
```clojure
(defn probability-all-circuits-receive-error []
  (let [n 10                                            ; number of errors
        k 8                                             ; number of circuits
        total-ways (Math/pow k n)
        favorable-ways (* (factorial k) (stirling2 n k))]
    (/ favorable-ways total-ways)))
```
:::



::: {.sourceClojure}
```clojure
(defn simulate-error-distribution []
  (let [circuits (vec (repeat 8 0))]
    (reduce (fn [acc _]
              (update acc (rand-int 8) inc))
            circuits
            (range 10))))
```
:::



::: {.sourceClojure}
```clojure
(defn all-circuits-have-error? [distribution]
  (every? pos? distribution))
```
:::



::: {.sourceClojure}
```clojure
(defn monte-carlo-simulation [num-simulations]
  (let [successes (atom 0)]
    (doseq [_ (range num-simulations)]
      (when (all-circuits-have-error? (simulate-error-distribution))
        (swap! successes inc)))
    (double (/ @successes num-simulations))))
```
:::


Helper functions


::: {.sourceClojure}
```clojure
(defn joint-probability
  "Helper function to calculate the joint probability of a subset of events."
  [probs subset]
  (reduce * (map #(nth probs %) subset)))
```
:::



::: {.sourceClojure}
```clojure
(defn subsets
  "Generate all non-empty subsets of a set of indices."
  [s]
  (filter seq (combo/subsets s)))
```
:::



::: {.sourceClojure}
```clojure
(defn power-set
  "Returns the power set of a given collection (set or vector)."
  [coll]
  (set (map set (combo/subsets (seq coll)))))
```
:::



::: {.sourceClojure}
```clojure
(defn probability-at-least-one
  "Calculate the probability of at least one event occurring given a collection of probabilities.
       Uses the inclusion-exclusion principle for any number of events."
  [probs]
  (let [p-none (reduce * (map #(- 1 %) probs))]
    (- 1 p-none)))
```
:::



::: {.sourceClojure}
```clojure
(defn solve-probabilities [b1 b2]
  (let [A (dge 2 2 [1 1
                    3 -1]
               {:layout :row})
        b (dv [b1 b2])
        LU (trf! A)
        x (mv (tri! LU) b)]
    x))
```
:::



::: {.sourceClojure}
```clojure
(defn nck
  "Calculates the binomial coefficient (n choose k) using iterative and recursive method."
  [n k]
  (if (or (< k 0) (> k n))
    0
    (let [k (min k (- n k))]
      (loop [result 1N, i 0]
        (if (= i k)
          result
          (recur
           (/ (* result (- n i)) (inc i))
           (inc i)))))))
```
:::



```{=html}
<div style="background-color:grey;height:2px;width:100%;"></div>
```



```{=html}
<div><pre><small><small>source: <a href="https://github.com/adabwana/f24-m6410-hw3/blob/master/src/assignments/hw3/utils.clj">src/assignments/hw3/utils.clj</a></small></small></pre></div>
```
